<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Data → HTML Converter</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .table-wrap { max-height: 60vh; overflow: auto; }
    th.sticky { position: sticky; top: 0; background: white; box-shadow: 0 1px 0 rgba(0,0,0,.08); }
    input[type=number]::-webkit-outer-spin-button, input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-7xl mx-auto p-6">
    <header class="mb-6 flex items-center justify-between">
      <h1 class="text-2xl md:text-3xl font-bold tracking-tight">Data → HTML Converter</h1>
      <a href="#" class="text-sm underline opacity-60 hover:opacity-100" onclick="window.scrollTo({top:0,behavior:'smooth'})">Top</a>
    </header>

    <!-- Controls -->
    <section class="grid md:grid-cols-3 gap-4 mb-6">
      <div class="p-4 bg-white rounded-2xl shadow">
        <label class="block text-sm font-medium mb-2">Load data (CSV / TSV / JSON)</label>
        <input id="fileInput" type="file" accept=".csv,.tsv,.json,.txt,.ndjson" class="block w-full text-sm" />
        <div class="mt-3 text-xs text-gray-500">or paste below</div>
      </div>

      <div class="p-4 bg-white rounded-2xl shadow">
        <label class="block text-sm font-medium mb-2">Options</label>
        <div class="flex flex-wrap gap-3 items-center">
          <select id="layout" class="px-3 py-2 rounded-xl bg-gray-100">
            <option value="table">Table</option>
            <option value="cards">Cards</option>
          </select>
          <label class="flex items-center gap-2 text-sm">
            <span>Rows / page</span>
            <input id="pageSize" type="number" min="1" value="50" class="w-20 px-2 py-1 rounded-lg bg-gray-100" />
          </label>
          <label class="flex items-center gap-2 text-sm">
            <input id="headerRow" type="checkbox" checked /> <span>First row has headers (CSV/TSV)</span>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <span>Split into columns</span>
            <input id="splitCols" type="number" min="1" value="1" class="w-16 px-2 py-1 rounded-lg bg-gray-100" />
          </label>
        </div>
      </div>

      <div class="p-4 bg-white rounded-2xl shadow flex flex-col gap-3">
        <label class="block text-sm font-medium">Quick actions</label>
        <div class="flex flex-wrap gap-2">
          <button id="btnRender" class="px-3 py-2 rounded-2xl bg-black text-white">Render</button>
          <button id="btnCopyHTML" class="px-3 py-2 rounded-2xl bg-gray-900 text-white">Copy HTML</button>
          <button id="btnDownloadHTML" class="px-3 py-2 rounded-2xl bg-gray-200">Download .html</button>
          <button id="btnClear" class="px-3 py-2 rounded-2xl bg-gray-200">Clear</button>
        </div>
        <input id="search" placeholder="Search…" class="px-3 py-2 rounded-xl bg-gray-100" />
      </div>
    </section>

    <section class="mb-6">
      <textarea id="paste" placeholder="Paste CSV / TSV / JSON / NDJSON here…" class="w-full h-40 p-3 rounded-2xl shadow bg-white"></textarea>
      <div class="text-xs text-gray-500 mt-2">Tip: For JSON array of objects, keys become columns automatically. NDJSON (one JSON per line) also works.</div>
    </section>

    <!-- Output -->
    <section class="space-y-3">
      <div id="meta" class="text-sm text-gray-600"></div>
      <div id="output" class="bg-white rounded-2xl shadow p-0"></div>
      <div id="pager" class="flex items-center gap-2 justify-end text-sm"></div>
    </section>
  </div>

  <script>
    const byId = id => document.getElementById(id);
    const state = { data: [], headers: [], page: 1, filteredIdx: [] };

    function detectFormat(text) {
      const t = text.trim();
      if (!t) return null;
      if (t[0] === '[' || t[0] === '{') return 'json';
      if (t.includes('\t')) return 'tsv';
      return 'csv';
    }

    function parseDelimited(text, delimiter=',') {
      const rows = [];
      let row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (c === '"') {
          if (inQuotes && text[i+1] === '"') { field += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (!inQuotes && (c === '\n' || c === '\r')) {
          if (field !== '' || row.length) { row.push(field); rows.push(row); row = []; field=''; }
          if (c === '\r' && text[i+1] === '\n') i++;
        } else if (!inQuotes && c === delimiter) {
          row.push(field); field = '';
        } else {
          field += c;
        }
        i++;
      }
      if (field !== '' || row.length) { row.push(field); rows.push(row); }
      return rows;
    }

    function parseJSONLike(text) {
      const t = text.trim();
      if (t.startsWith('[')) return JSON.parse(t);
      return t.split(/\r?\n/).filter(Boolean).map(line => JSON.parse(line));
    }

    function normalizeToObjects(rows, useHeader=true) {
      if (!rows.length) return { headers: [], data: [] };
      let headers = [];
      if (useHeader) {
        headers = rows[0].map((h, i) => (h?.toString()?.trim() || `col_${i+1}`));
        rows = rows.slice(1);
      } else {
        const maxLen = Math.max(...rows.map(r => r.length));
        headers = Array.from({length: maxLen}, (_, i) => `col_${i+1}`);
      }
      const data = rows.map(r => Object.fromEntries(headers.map((h, i) => [h, r[i] ?? ''])));
      return { headers, data };
    }

    function fromJSONRecords(records) {
      const headerSet = new Set();
      records.forEach(obj => Object.keys(obj || {}).forEach(k => headerSet.add(k)));
      const headers = Array.from(headerSet);
      const data = records.map(obj => {
        const row = {};
        headers.forEach(h => row[h] = obj?.[h] ?? '');
        return row;
      });
      return { headers, data };
    }

    function readTextFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    async function ingest(text) {
      const fmt = detectFormat(text);
      if (!fmt) { alert('No data detected'); return; }
      let headers = [], data = [];

      if (fmt === 'json') {
        const records = parseJSONLike(text);
        ({ headers, data } = fromJSONRecords(records));
      } else {
        const delimiter = fmt === 'tsv' ? '\t' : ',';
        const rows = parseDelimited(text, delimiter);
        ({ headers, data } = normalizeToObjects(rows, byId('headerRow').checked));
      }

      // --- NEW: handle single column split ---
      const splitCols = parseInt(byId('splitCols').value, 10) || 1;
      if (headers.length === 1 && splitCols > 1) {
        const colName = headers[0];
        const values = data.map(r => r[colName]);
        headers = Array.from({length: splitCols}, (_, i) => `col_${i+1}`);
        data = [];
        for (let i = 0; i < values.length; i += splitCols) {
          const row = {};
          headers.forEach((h, j) => { row[h] = values[i+j] || ''; });
          data.push(row);
        }
      }

      state.headers = headers;
      state.data = data;
    }

    // (rest of render, table, cards, pager, copy/download same as before)
    // ...

    const demoCSV = `value\nA\nB\nC\nD\nE\nF`;
    byId('paste').value = demoCSV;
    ingest(demoCSV).then(render);
  </script>
</body>
</html>
